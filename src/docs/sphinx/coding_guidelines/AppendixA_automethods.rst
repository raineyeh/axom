***************************************************************
Appendix A  Compiler-generated Member Functions
***************************************************************


This appendix provides background information related to the guidelines
in Section 6.3. There, we provide guidelines that help to decide when to 
define class methods that may be generated automatically by a compiler and 
when it's OK to rely on the compiler-generated versions.  Here, we describe
the conditions under which compilers generate methods automatically and how
those compiler-generated methods work.


========================================================
A.1 Rules for generating methods automatically
========================================================

Consider the following simple class::

   class MyClass 
   {
   public:

      int x;

   };

How many methods does it have? None?

Actually, prior to C++11 MyClass has **four** methods: a default constructor, 
destructor, copy constructor, and copy-assignment operator. All of these are 
generated by the compiler. With C++11, MyClass may have **six** methods. 
These are the four pre-C++11 compiler-generated methods, plus the move
constructor and move-assignment operator. 

The C++ compiler rules for generating class member functions are:

   * The parameter-less default constructor is generated if a class does 
     not explicitly define *any* constructor and all base classes and data 
     members are default-constructible. This means that once you declare a copy 
     constructor (perhaps to disable the automatically provided one), 
     the compiler will not supply a default construtor.
   * The destructor is automatically supplied if possible, based on the 
     members and the base classes.
   * A copy constructor is generated if all base classes and members are 
     copy-constructible. Note that reference members are copy-constructible.
   * The copy-assignment operator is generated if all base classes and members 
     are copy-assignable. For this purpose, reference members are not 
     considered copy-assignable.
   * In C++11, a move constructor is supplied unless the class has any of 
     the following methods defined explicitly: copy constructor, 
     copy-assignment operator, move-assignment operator, or destructor. If 
     the move constructor cannot be implemented because not all base classes 
     or members are move-constructible, the supplied move constructor will 
     be defined as deleted.
   * In C++11, a move-assignment operator is generated under the same 
     conditions as the move constructor.

Recall that compiler-generated default constructors, copy constructors, and 
copy-assignment operators, will recursively invoke similar operations for 
base class objects and data members. Similarly, compiler-generated move
constructors and move-assignment operators will recursively invoke those
operations for base class objects and data members. 


========================================================
A.2 Behavior of automatically-generated methods
========================================================

The importance of applying the "rules of 3, 4, or 5" guidelines in Section 
6.3 is underscored by the fact that compiler-generated methods can have 
different behaviors depending on how they are used. For example, consider
MyClass defined above.

If MyClass has a user-defined constructor, then

.. code-block:: cpp

    MyClass item1; 

and

.. code-block:: cpp

    MyClass item2 = MyClass(); 

will both call your the user-defined default constructor "MyClass()" and there
is only one behavior.

However, if MyClass relies on the compiler-generated constructor 

.. code-block:: cpp

    MyClass item1; 

performs *default initialization*, while 

.. code-block:: cpp

    MyClass item2 = MyClass(); 

performs *value initialization*.

Default initialization calls the constructors of any base classes and nothing 
else. Since constructors for intrinsic types do not do anything, that means 
all member variables will have garbage data; specifically, whatever data was 
last seen in those addresses.

Value initialization also calls the constructors of any base classes. Then, 
one of two things happens:

   * If MyClass is a POD class (all member variables are either intrinsic 
     types or classes that only contain intrinsic types and have no 
     user-defined constructor/destructor), all data is initialized to 0.
   * If MyClass is not a POD class, the constructor does not touch any data,
     which is the same as default initialization (so member variables have 
     garbage data unless explicitly constructed otherwise).

One last point worth noting:

Intrinsic types, such as int, float, bool, pointers, etc. have constructors 
that do nothing (not even initialize to zero), destructors that do nothing, 
and copy constructors and copy assignment-ers that blindly copy the bytes over.
