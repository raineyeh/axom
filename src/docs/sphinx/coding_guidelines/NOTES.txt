Rule of Three becomes the Rule of Three, Four and Five:

Each class should explicitly define exactly one of the following set of special
member functions:

-- None (simple classes where automatically-gen versions are correct and fast)
-- Destructor, copy constructor, copy assignment operator

In addition, each class that explicitly defines a destructor may explicitly
define a move constructor and/or a move assignment operator (C++11).

Usually, one of the following sets of special member functions is sensible:

-- None (for simple classes where generated special member functions are correct and fast)
-- Destructor, copy constructor, copy assignment operator (the class will not be movable)
-- Destructor, move constructor, move assignment operator (the class will not be copyable,
   useful for resource-managing classes where the underlying resource is not copyable)
-- Destructor, copy constructor, copy assignment operator, move constructor (because of copy elision,
   there is no overhead if the copy assignment operator takes its argument by value)
-- Destructor, copy constructor, copy assignment operator, move constructor, move assignment operator



Notes:

-- move constructor and move assignment operator won't be generated for a class that
   explicitly declares any of the other special member functions (default ctor,
   copy ctor, or copy assignment operator)
-- copy constructor and copy assignment operator won't be generated for a class that
   explicitly declares a move constructor or move assignment operator

Valid C++03 polymorphic base class:

class C {
public:
  virtual ~C() { }   // allow subtype polymorphism
};

should be rewritten as:

class C {
  C(const C&) = default;               // Copy constructor
  C(C&&) = default;                    // Move constructor
  C& operator=(const C&) & = default;  // Copy assignment operator
  C& operator=(C&&) & = default;       // Move assignment operator
  virtual ~C() { }                     // Destructor
};



In contrast to the Rule of the Big Three, where failing to adhere to the rule can cause serious damage,
not explicitly declaring the move constructor and move assignment operator is generally fine but often
suboptimal with respect to efficiency. This is not symmetric to the traditional C++03 behavior with respect
to auto-generation of copy constructor and copy assignment operator, but is much safer. So the possibility
to define move constructors and move assignment operators is very useful and creates new possibilities
(purely movable classes), but classes that adhere to the C++03 Rule of the Big Three will still be fine.

For resource-managing classes you can define the copy constructor and copy assignment operator as deleted
(which counts as definition) if the underlying resource cannot be copied.  For example:

class D {
  D(const D&) = deleted;               // Copy constructor
  D(D&&) = deleted;                    // Move constructor
  D& operator=(const D&) & = default;  // Copy assignment operator
  D& operator=(D&&) & = default;       // Move assignment operator
  virtual ~D() { }                             // Destructor
};

Often you still want move constructor and move assignment operator. Copy and move assignment operators
will often be implemented using swap, as in C++03. [[[Need examples]]]

If you have a move constructor and move assignmen operator, specializing std::swap will become unimportant
because the generic std::swap uses the moveconstructor and move assignment operator if available, and that
should be fast enough.

Classes that are not meant for resource management (i.e., no non-empty destructor) or subtype polymorphism
(i.e., no virtual destructor) should declare none of the five special member functions; they will all be
auto-generated and behave correct and fast.

