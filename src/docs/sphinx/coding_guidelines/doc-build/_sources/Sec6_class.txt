Class Design and Implementation
C++ class definitions
This section contains guidelines for C++ class definitions. The summary here uses bold-type numbers and text to illustrate the basic structure.
Details about individual items follow.
(1) Class documentation prologue
class MyClass
{
(2) "friend" declarations (if needed)
public:
(3a) static member function declarations (if needed)
(3b) public member function declarations
protected:
(4a) protected member function declarations (if needed)
(4b) protected data member declarations (if needed)
private:
(5a) private static data member declarations (if needed)
(5b) private member function declarations
(5c) private data member declarations

};
The numbers in parentheses in the following guidelines correspond to the numbered items in the preceding summary.

A documentation prologue (1) must precede each class definition; see Section
blah…
Both the opening curly brace "{" and the closing curly brace "};" for a class
definition must be on their own source lines and must be aligned vertically with
the "class" reserved word.
Generally, "friend" declarations should be avoided. If needed, they must appear
within the body of a class definition before any class member declarations (2).
Class members must be declared in the following order: "public" (3),
"protected" (4), and "private" (5). That is, order members by decreasing scope
of audience.
Using static class members (methods and data) should be considered carefully.
When it is determined that they should be used, they must appear first in the
appropriate section (3a, 5a).
Within each set of member declarations (i.e., public, protected, private), all
function declarations must appear before data member declarations (3a-3b),
(4a-4b), (5a-5c).
If the class contains nested classes or other types, these definitions should ap

pear before other class members (i.e., data and functions) within the
appropriate section ("public" or "private") of the enclosing class definition.
Each class member function and data member declaration must be
documented according to the guidelines described in Sections blah…

Class member declarations
All class data members should be declared "private". Information hiding is an
essential aspect of good software engineering and private data is the best
means for a class to preserve its invariants. In other words, the class should
maintain control of how object state can be modified to minimize side effects.
"Public" data members in classes should be avoided. Restricting direct access
to class data enforces encapsulation and facilitates design changes through
refactoring.
"Protected" data members in classes should be avoided. Allowing subclasses
direct access to base class data often causes the design of an inheritance
hierarchy to diverge and degrade over time.
A class constructor that takes a single (non-default) argument must be
declared "explicit". This will prevent compilers from performing unexpected
(and unwanted!) implicit type conversions. For example,
class MyClass
{
public:
explicit MyClass(int i, double x = 0.0);
};

Each class member function that does not change the object state must be
declared "const". This helps compilers detect usage errors.
Each class member function that returns a class data member that should not
be changed by the caller must be declared "const" and must return the data
member as a "const" reference or pointer, whichever is appropriate.
Sometimes, both "const" and non-"const" versions of "getter" functions are
needed so that callers may declare the variable that holds the return value of
such a function call with the appropriate "const-ness".

Class implementation
Every class data member must be initialized (using default values when

appropriate) in the class constructor(s). That is, an initializer/initialization must
be provided for every class data member so that every object is in a
well-defined state upon construction. Generally, this requires a user-defined
default constructor when a class has POD members. Do not assume that a
compiler-generated default constructor will leave any member variable in a
well-defined state.
Exception: If a class has no member variables, and is derived from a base class with default constructor that provides full member initialization, a
user-defined default constructor is not needed since the compiler-generated version will suffice.

Data member initialization should be used instead of assignment in
constructors, especially for small classes. Initialization prevents needless
run-time work.
For classes with complex data members, assignment within the body of the
constructor may be preferable. However, if the initialization process is
sufficiently complex, it should not be done in a constructor. This is best done
in another method called after object creation, such as "init()".
When using initialization instead of assignment to set data member values in a
constructor, the data members should always be initialized in the order in
which they appear in the class declaration. Compilers adhere to this order
regardless of the order that members appear in the class initialization list. So
you may as well agree with the compiler rules.
A constructor must not call a virtual function on any data member object since
an overridden method defined in a subclass cannot be called until the object is
constructed fully. There is no general guarantee that data members are
fully-created before a constructor exits.
All memory allocated in a class constructor must be de-allocated in the class
destructor. The intent of constructors is to acquire resources and the intent of
destructors is to free those resources.
The following guidelines for class methods that may be automatically
generated by a compiler (i.e., default constructor, destructor, copy constructor,
and copy assignment operator) must be followed:
The default constructor, copy constructor, and copy assignment operator should be declared private and unimplemented when the intent
is that such methods should never be called. This is a good way to enable the compiler to catch unintended usage. For example,
class MyClass
{
// ...
private:
// The following methods are not implemented
MyClass();
MyClass(const MyClass&);

void operator=(const MyClass&);
// ...
};
The default constructor, copy constructor, destructor, and copy assignment may be left undeclared when the compiler-generated versions
are appropriate. In this case, the class header file should contain comments indicating that the compiler-generated versions of these
methods will be used. Note C++11 supports the "default" keyword to make this clear. It would be nice to use, but would need to be
controlled for conditional compilation. Exception: If a class inherits from a base class that declares these methods private, the subclass
need not declare the methods private. However, a comment should be provided in the derived class stating that the parent class enforces
the non-copyable properties of the class.

If a class is default-constructable and has POD data members, including raw pointers, the default constructor must be defined explicitly
and the data members must be initialized explicitly. A compiler-generated version of a default constructor will not initialize such members,
in general.

Each class must follow the rule of three: if any of the destructor, copy constructor, and copy-assignment operator is explicitly defined,
then the others must be defined or declared private and left unimplemented. It is best not to mix compiler-generated and explicit versions
of these methods. Rule of five in C++11…

By convention, functor classes should have copy constructors and copy-assignment operators. Typically, the compiler-generated version
is what is desired in this case when the class has no state or non-POD data members. Since such classes are small and simple typically,
the compiler-generated versions of these methods may be used without documenting the use of default value semantics in the functor
definition.

An explicit implementation of a class copy-assignment operator must check for
assignment to self, and must return a reference to "*this" after copying all data
members. The "copy-and-swap" idiom should be used. For example,
MyClass& MyClass::operator= (const MyClass& rhs)
{
if (this != &rhs) {
MyClass temp(rhs);
swap(temp);
}
return *this;
}
Note that the copy-and-swap idiom uses the copy constructor to create a temporary object and calls a swap method provided by the class which
copies the individual class members from the temporary object. When this idiom is used, the swap method must call the swap method of each of
its base classes.

A class that provides an explicit implementation of the copy constructor and
copy-assignment operator must call the corresponding copy constructor and
copy-assignment operator in each of its base classes.

Inheritance
Class composition should often be used instead of inheritance to extend
behavior. Looser coupling between objects is typically more flexible and easier
to maintain.
Class hierarchies should be designed so that subclasses inherit from abstract
interfaces; i.e., pure virtual base classes. Inheritance is often done to reuse
code that exists in a base class. However, there are usually better design

choices to achieve reuse. Good object-oriented use of inheritance is to reuse
existing calling code by exploiting base class interfaces using polymorphism.
Put another way, "interface inheritance" should be used instead of
"implementation inheritance".
Deep inheritance hierarchies; i.e., more than 2 or 3 levels, should be avoided.
Multiple inheritance should be restricted so that only one base class contains
methods that are not "pure virtual"; i.e., adhering to the Java model of
inheritance is most effective for avoiding abuse of inheritance.
One should not inherit from a class that was not designed to be a base class
(e.g., if it does not have a virtual destructor). Doing so is bad practice and can
cause problems that may not be reported by a compiler; e.g., hiding base class
members. To add functionality, one should employ class composition rather
than "tweaking" an existing class.
The destructor of a class that is designed to be a base class must be declared
"virtual". However, sometimes a destructor should not be declared virtual, such
as when deletion through a pointer to a base class object should be disallowed.
"Private" and "protected" inheritance must not be used unless you absolutely
understand the ramifications of such a choice and are sure that it will not
create design and implementation problems. There almost always exist
alternatives to avoid these forms of inheritance.
Virtual functions should be overridden responsibly. That is, the pre- and
post-conditions, default arguments, etc. of the virtual functions should be
preserved. Also, the behavior of an overridden virtual function should not devia
te from the intent of the base class. Remember that derived classes are subsets
, not supersets, of their base classes.
A virtual function in a base class should only be defined if is behavior is always
valid default behavior for any derived class.
Inherited non-virtual methods must not be overloaded or hidden.
If a virtual function in a base class is not overridden in any derived class then
the method should not be declared virtual.
If each derived class has to provide specific behavior for a base class virtual
function, then it should be declared pure virtual.
Virtual functions must not be called in a class constructor or destructor. Doing
so is undefined behavior according to the C++ standard. Even if it seems to
work correctly, it is fragile and potentially not portable.

The copy-assignment operator of a derived class should use the copy-and-swa
p idiom described in item blah. This is preferred to explicit assignment of base
class data members since the code is less coupled and since some base class
data members may be private. For example, here is the preferred way to
implement a swap method in a derived class.
void DerivedClass::swap(const DerivedClass& rhs)
{
BaseClass::swap(rhs);
// assign DerivedClass data members...
}

